# Динамические строки

dynstr -- небольшой проект, содержащий в себе реализацию класса динамических строк, состоящих из однобайтовых ASCII-символов и поддерживающих конкатенацию, вставку, модификацию и удаление подстрок или отдельных символов.

Динамические строки -- это изменяемые (mutable) строки, представленные одномерным массивом `char`, расположенным на куче (heap). Процесс выделения памяти (memory allocation) для строки инкапсулирован внутри класса: динамическая строка осуществляет автоматическое выделение и высвобождение блоков памяти по мере необходимости.

Сам класс динамических строк написан на стандарте версии C++11, хотя проект также содержит тесты, написанные при помощи библиотеки [`googletest`](https://github.com/google/googletest), требующей C++14. При помощи утилиты `CMake` программа и тесты могут быть скомпилированы и компилируются в исполняемые файлы с использованием необходимой версии C++. 

## Постановка задачи

Класс динамических строк удовлетворяет следующим условиям:

1. Написан на C++11 без сторонних библиотек. Не использует в своей основе какую-либо другую реализацию динамических строк, контейнеров или умных указателей STL.
2. Класс не шаблонный. Поддерживает строки произвольного размера, используя базовые операции работы с динамическим хипом (функции `malloc()`, `free()` или операторы `new`, `delete`) для манипуляции последовательностями символов типа `char`.
3. Имеет конструктор копирования, оператор присваивания и поддерживает move-семантику. 

У класса есть "внешний" оператор сложения двух строк.

Реализация не содержит в себе какие-то изощренные методы оптимизации (типа COW и многопоточной поддержки).

Пример написан с использованием этого класса динамических строк и какого-либо контейнера STL. Программа принимает список строк, затем выдает его в порядке, обратном лексикографическому без учета регистра.

Программа-пример работает из командной строки.

## Реализация

Класс динамической строки изнутри представляет собой обычный массив `char`'ов длины `length` и вместимости `capacity`. Так, `length` -- это длина строки, т.е. количество входящих в нее символов без нуль-символа `'\0'`, тогда как вместимости `capacity` -- это количество символов, которые можно вставить в строку, прежде чем потребуется реаллокация нового блока памяти для миссива `char`'ов.

Например, если изначально пустая строка имеет вместимость `capacity`, равную трём, то в нее влезет ровно 3 символа. Добавление же 4-го символа при помощи метода `Add('...')` повлечет за собой реаллокацию и выделение нового блока памяти в 2 раза большей длины, в который будут скопированы все символы строки и добавлен новый 4-ый. При этом при вызове про `Concatenate("...")` вместительность растет ровно на столько символов, сколько  потребуется для вмещения добавляемой строки (если ее длина больше текущей вместительности).

### Свойства

| Тип         | Свойство     | Описание   |
|:------------|:-------------|:-----------|
| `const char*` | `Characters()` | Возвращает последовательность `char`'ов, из которой состоит динамическая строка |
| `uint32_t`    | `Length()` | Возвращает длину `length` динамической строки |
| `uint32_t`    | `Capacity()` | Возвращает вместимость `capacity` динамической строки |

### Методы

| Сигнатура метода | Описание |
|:-----------------|:---------|
| `void Add(char character)` | Добавляет один указанный символ `character` в конец строки |
| `void Concatenate(const char* value)` | Добавляет последовательность символов `value` в конец строки |
| `void Insert(size_t index, char character)` | Вставляет один символ `character` на указанную позицию `index` внутри динамической строки |
| `void Remove(size_t index)` | Удаляет символ по указанному индексу `index` внутри динамической строки. |
| `size_t Reserve(size_t newCapacity)` | Устанавливает указанное значение `newCapacity` в качестве новой вместимости динамической строки |
| `void Clear()` | Очищает динамическую строку, делая ее пустой |
| `bool Equals(const DynamicString& other)` | Проверяет, равна ли данная динамическая строка строке `other`. Метод также имеет перегрузку для последовательности `const char*` |

Помимо всего прочего, в классе динамических строк реализованы операторы присваивания, сравнения, сложения, взятия символа по индексу и ввода, вывода из потока, а также в классе присутствуют методы `begin()` и `end()`, позволяющие получить итератор динамической строки.

### Пример

Следующий пример иллюстрирует использование динамических строк с использованием STL контейнера `vector`.

```cpp
int main()
{
    std::vector<DynamicString> strings;
    strings.reserve(10);

    while (true)
    {
        DynamicString string(16uLL);
        std::cin >> string;
        if (string.Equals("")) break;
        strings.push_back(std::move(string));
    }

    std::sort(strings.begin(), strings.end(),
        DynamicStringComparator::Lexicographical_Reversed_CaseInsensitive);

    for (const DynamicString& string : strings)
        std::cout << string << std::endl;
}
```

В этом примере мы последовательно считываем строки из потока ввода и складываем их в общий список `strings` до тех пор, пока не встретим пустую строку. При этом не происходит никаких копирований объектов строк, так как класс поддерживает move-семантику. После мы сортируем полученный список с помощью имплементированного итератора для динамических строк в обратном лексикографическом порядке без учета регистра символов.

Таким образом, для данного набора введенных в терминале строк:

```sh
{ "a", "B", "c", "D" }
```

программа напечатает их в следующем порядке вывода:

```sh
{ "D", "c", "B", "a" }
```

## Запуск

Убедитесь, что репозиторий проекта был склонирован с флагом `--recursive`, чтобы дополнительно склонировать библиотеку `googletest`, добавленную в проект как подмодуль. Сама реализация класса динамических строк ни от каких библиотек не зависит, поэтому, вообще говоря, он может быть скомпилирован и обособленно. Сборка проекта может быть создана, а проект скомпилирован в исполняемый файл при помощи утилиты `CMake`. Для Windows также может потребоваться инструмент разработки `MinGW`.

### Unix
```sh
cmake -S . -B build
make -C build
``` 

### Windows
```sh
# On windows:
cmake -S . -B build -G "MinGW Makefiles"
mingw32-make -C build
``` 

В результате в директории `bin` будут находиться два исполняемых файла для самой скомпилированной программы и тестов: 

```tree
bin/
|-- dynstr.exe       # Программа
`-- test-dynstr.exe  # Тесты
```

## Тестирование

Программа содержит тесты, написанные при помощи библиотеки [`googletest`](https://github.com/google/googletest). Все необходимые зависимости подключены при сборке с помощью `CMake`.

### Пример

Написанные в проеке юнит-тесты одновременно представляют актуальную документацию к классу динамических строк. Так, в одном из тестов декларируются следующие требования к пустой строке, получаемой при инициализации без параметров:

1. Массив `char`'ов совпадает с литералом пустой строки `""`;
2. Длина строки равна `0`;
3. Вместимость строки по умолчанию равна `1`. (подробнее о вместимости см. Реализация)

```cpp
#include <gtest/gtest.h>
#include "DynamicString.h"

TEST(DynstrTest, IsEmptyOnInit)
{
    DynamicString string;

    EXPECT_STREQ(string.Characters(), "");
    EXPECT_EQ(string.Length(), 0);
    EXPECT_EQ(string.Capacity(), 1);
}
```

Следующий пример юнит-теста осуществляет проверку того факта, что строка умеет динамически выделять для себя память, увеличивая значение своей вместимости `capacity`.

Вначале создается пустая динамическая строка длины `0` и замеряется ее текущая вместимость (по умолчанию она равна `1`, как того требует юнит-тест выше). Затем в строку последовательно добавляют два символа: при вместимости, равной единице, первый в нее влезает, тогда как второй уже потребует выделить новый блок памяти (в 2 раза больший предыдущего). Таким образом, тест ожидает получить новую вместимость, которая была бы больше изначальной и равнялась `2`. 

```cpp
TEST(DynstrTest, ReallocatesMemory)
{
    DynamicString string;
    size_t initialCapacity = string.Capacity();

    string.Add('A');
    string.Add('B');
    size_t newCapacity = string.Capacity();

    EXPECT_STREQ(string.Characters(), "AB");
    EXPECT_EQ(string.Length(), 2);
    EXPECT_EQ(string.Capacity(), 2);

    EXPECT_GT(newCapacity, initialCapacity);
}
```

### Запуск

Чтобы запустить все юнит-тесты из директории `test`, достаточно скомпилировать проект и исполнить запускаемый файл:

```sh
./bin/test-dynstr.exe
```
