# Динамические строки

dynstr -- небольшой проект, содержащий в себе реализацию класса динамических строк, поддерживающих конкатенацию, вставку, модификацию и удаление подстрок или отдельных символов.

Динамические строки -- это изменяемые (mutable) строки, представленные одномерным массивом `char`, расположенным на куче (heap). Процесс выделения памяти (memory allocation) для строки инкапсулирован внутри класса: динамическая строка осуществляет автоматическое выделение и высвобождение блоков памяти по мере необходимости.

Сам класс динамических строк написан на стандарте версии C++11, хотя проект также содержит тесты, написанные при помощи библиотеки [`googletest`](https://github.com/google/googletest), требующей C++14. При помощи утилиты `CMake` программа и тесты могут быть скомпилированы и компилируются в исполняемые файлы с использованием необходимой версии C++. 

## Постановка задачи

Класс динамических строк удовлетворяет следующим условиям:

1. Написан на C++11 без сторонних библиотек. Не использует в своей основе какую-либо другую реализацию динамических строк, контейнеров или умных указателей STL.
2. Класс не шаблонный. Поддерживает строки произвольного размера, используя базовые операции работы с динамическим хипом (функции `malloc()`, `free()` или операторы `new`, `delete`) для манипуляции последовательностями символов типа `char`.
3. Имеет конструктор копирования, оператор присваивания и поддерживает move-семантику. 

У класса есть "внешний" оператор сложения двух строк.

Реализация не содержит в себе какие-то изощренные методы оптимизации (типа COW и многопоточной поддержки).

Пример написан с использованием этого класса динамических строк и какого-либо контейнера STL. Программа принимает список строк, затем выдает его в порядке, обратном лексикографическому без учета регистра.

Программа-пример работает из командной строки.

## Реализация

Класс динамического массива изнутри представляет собой обычный массив `char`'ов длины `length` и вместимости `capacity`. Так, `length` -- это длина строки, т.е. количество входящих в нее символов без нуль-символа `'\0'`, тогда как вместимости `capacity` -- это количество символов, которые можно вставить в строку, прежде чем потребуется реаллокация нового блока памяти для миссива `char`'ов.

Например, если изначально пустая строка имеет вместимость `capacity`, равную трём, то в нее влезет ровно 3 символа. Добавление же 4-го символа при помощи метода `Add('...')` повлечет за собой реаллокацию и выделение нового блока памяти в 2 раза большей длины, в который будут скопированы все символы строки и добавлен новый 4-ый. При этом при вызове про `Concatenate("...")` вместительность растет ровно на столько символов, сколько  потребуется для вмещения добавляемой строки (если ее длина больше текущей вместительности).

### Свойства

| Тип         | Свойство     | Описание   |
|:------------|:-------------|:-----------|
| const char* | Characters() | Возвращает последовательность `char`'ов, из которой состоит динамическая строка |
| uint32_t    | Length() | Возвращает длину `length` динамической строки |
| uint32_t    | Capacity() | Возвращает вместимость `capacity` динамической строки |

### Методы

| Сигнатура метода | Описание |
|:-----------------|:---------|
| `void Add(char character)` | Добавляет один символ `char` в конец строки |
| `void Concatenate(const char* value)` | Добавляет один последовательность  `char`'ов в конец строки |
| `void Insert(size_t index, char character)` | Вставляет один символ `char` по указанной позиции внутри динамической строки |
| `void Remove(size_t index)` | Конец отрезка значений x, на котором будет строится график функции (по умолчанию `from`=`10.0`) |
| `size_t Reserve(size_t newCapacity)` | Устанавливает указанное значение в качестве новой вместимости динамической строки |
| `void Clear()` | Очищает динамическую строку, делая ее пустой |
| `bool Equals(const DynamicString& other)` | Проверяет, равна ли данная динамическая строка строке `other`. Метод также имеет перегрузку для последовательности `const char*` |

### Пример

```sh
# coming soon with a showcase of the possibilities of DynamicString class
```

## Запуск

Вы можете создать сборку и скомпилировать программу при помощи утилиты `CMake`.

### Unix
```sh
cmake -S . -B build
make -C build
``` 

### Windows
```sh
# On windows:
cmake -S . -B build -G "MinGW Makefiles"
mingw32-make -C build
``` 

В директории `bin/` будут находиться два исполняемых файла для самой скомпилированной программы и тестов: 

```tree
bin/
|-- dynstr.exe       # Программа
`-- test-dynstr.exe  # Тесты
```

## Тестирование

Программа содержит тесты, написанные при помощи библиотеки [`googletest`](https://github.com/google/googletest). Все необходимые зависимости подключены при сборке с помощью `CMake`.

### Пример

Написанные в проеке юнит-тесты одновременно представляют актуальную документацию к классу динамических строк. Так, в одном из тестов декларируются следующие требования к пустой строке, получаемой при инициализации без параметров:

1. Массив `char`'ов совпадает с литералом пустой строки `""`;
2. Длина строки равна `0`;
3. Вместимость строки по умолчанию равна `1`. (подробнее о вместимости см. Реализация)

```cpp
#include <gtest/gtest.h>
#include "DynamicString.h"

TEST(DynstrTest, IsEmptyOnInit)
{
    DynamicString string;

    EXPECT_STREQ(string.Characters(), "");
    EXPECT_EQ(string.Length(), 0);
    EXPECT_EQ(string.Capacity(), 1);
}
```

Следующий пример юнит-теста осуществляет проверку того факта, что строка умеет динамически выделять для себя память, увеличивая значение своей вместимости `capacity`.

Вначале создается пустая динамическая строка длины `0` и замеряется ее текущая вместимость (по умолчанию она равна `1`, как того требует юнит-тест выше). Затем в строку последовательно добавляют два символа: при вместимости, равной единице, первый в нее влезает, тогда как второй уже потребует выделить новый блок памяти (в 2 раза больший предыдущего). Таким образом, тест ожидает получить новую вместимость, которая была бы больше изначальной и равнялась `2`. 

```cpp
TEST(DynstrTest, ReallocatesMemory)
{
    DynamicString string;
    size_t initialCapacity = string.Capacity();

    string.Add('A');
    string.Add('B');
    size_t newCapacity = string.Capacity();

    EXPECT_STREQ(string.Characters(), "AB");
    EXPECT_EQ(string.Length(), 2);
    EXPECT_EQ(string.Capacity(), 2);

    EXPECT_GT(newCapacity, initialCapacity);
}
```

### Запуск

Чтобы запустить все юнит-тесты из директории `test`, достаточно скомпилировать программу и исполнить запускаемый файл:

```sh
./bin/test-dynstr.exe
```